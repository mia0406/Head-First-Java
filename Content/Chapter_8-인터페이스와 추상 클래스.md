
### Chapter 8: 인터페이스와 추상 클래스
#### 1. API
- 클래스 중에는 인스턴스를 만들면 안되는 것도 존재한다.
- 특정 유형에 대해 'new' 키워드를 쓸 수 없게 하는 방법은 클래스를 abstract로 지정하면된다. 그 유형의 인스턴스를 만들 수 없다. 하지만 그 추상 유형(abstract type)을 레퍼런스로 사용할 수는 있다.
- 추상 클래스는 확장하지 않으면 거의 쓸모도 없고, 가치나 목적도 없다. 추상 클래스를 만들었을 대 실제 실행 중에 처리하는 것은 그 추상 클래스의 하위클래스 인스턴스이다.

- 추상 클래스가 아닌 것은 구상 클래스라고 부른다.

- 클래스말고도 특정 메소드에 대해서 abstract로 지정할 수 있다. 이런 추상 메소드는 반드시 오버라이드해야하는 메소드이다.

```JAVA
    public abstract void eat();
```

- 추상 메소드는 몸통이 없다. 중괄호도 없다.  다형성을 위해 존재할 뿐이다. 즉, 상속 트리에서 처음으로 등장하는 구상 클래스에서 모든 추상 메소드를 구현해야 한다.
    - 물론, 그 추상메소드를 자기 밑의 하위 클래스(이 하위 클래스도 구상 클래스가 아니라 추상클래스이어야 한다)에게 미룰 수도 있다. 근데 어쨌든 구상 클래스가 등장한다? 그 구상 클래스에서 추상 메소드를 무조건! 구현해야 한다.
- 추상 클래스가 아닌 클래스에 추상 메소드를 집어넣을 수는 없다. 클래스에 추상 메소드가 하나라도 존재한다면 그 클래스도 추상 메소드로 바꿔야 한다. 다만 추상 클래스 안에 추상 메소드만 있어야 되는 건 아니다. 추상메소드와 구상 메소드를 모두 집어넣을 수 있다.

- 추상클래스를 만드는 이유?

    → 실제 메소드 코드를 전혀 집어넣지는 않더라도 일련의 하위클래스를 위한 규약(protocol)의 일부를 정의하기 위한 것

    - 어떤 장점이 있는가?

        → 추상 메소드는 다형성을 활용하기 위해 "이 유형에 속하는 모든 하위클래스 유형에는 이 메소드가 있어야 한다"는 것을 지정하기 위해 필요한 것

- 추상 유형의 인스턴스를 새로 만들 수는 없지만 그 유형의 객체를 저장하기 위한 배열 객체를 만드는 것은 가능하다.

```JAVA
    public abstract class Animal(){}
    public class AnimalTest{

    	public static void main(String[] args){

    		private Animal[] arr=new Animal[5]; // 이렇게 유형으로 사용하는 것은 가능
    	}
    }
```

<Object 클래스>

- 자바에서 모든 클래스는 Object라는 클래스를 확장한 것, 어떤 클래스를 만들더라도 그 클래스는 반드시 Object 클래스를 확장한 클래스로 만들어진다.

- object 클래스 메소드
    - boolean equals() : 두 객체가 '같은' 것으로 볼 수 있을지 판단
    - Class getClass() : 실제 클래스 유형을 알려주는 메소드, 어떤 클래스의 인스턴스인지 알 수 있도록 그 객체 클래스 리턴
    - int hashCode() : 그 객체에 해당하는 해시코드(고유 ID 같은?) 출력
    - String toString()

- Object 클래스는 추상 클래스가 아니다. 그래서 모든 클래스에서 오버로이드할 필요 없이 그대로 사용하면 된다.
- Object 객체는 스레드 동기화할 때 많이 사용
- Object 클래스가 쓰이는 2가지 용도
    1. 임의 클래스에 대해 어떤 작업을 하는 메소드를 만들 때 다형적 유형으로 사용하는 경우
    2. 자바에 있는 모든 객체에서 실행 중에 필요한 진짜 메소드 코드를 제공하기 위함(왜냐하면 모든 클래스는 object 클래스를 상속받기 때문)

    → Object에서 스레드와 관련된 중요한 메소드도 존재한다.

* 왜 Object로 메소드의 인자와 유형으로 사용하지 않는가?
-> 자바에서 코드를 보호하는 가장 중요한 메커니즘 가운데 하나인 '유형 안정성'이 완전히 무의미해지기 때문, 자바에서는 유형 안정성을 통해서 어떤 객체 유형에 대해 요구해야 할 것을 엉뚱한 객체에 요구하는 일이 없도록 보장해준다.

* Object 유형으로 레퍼런스를 쓰게 된다면 대가를 치뤄야 한다.
  1. ArrayList
      * ArrayList<Object>에서 나오는 객체는 실제 객체의 유형이나 목록에 객체를 추가했을 때의 레퍼런스 유형하고는 상관 없이 무조건 Object 유형의 레퍼런스로 나오게 된다.
  2. 메소드
    * 어떤 객체를 Object 레퍼런스 유형을 써서 참조하면 자바에서는 항상 그 레퍼런스가 Object 유형의 인스턴스를 참조하고 있다고 생각하기 때문에 그 객체에 대해서는 Object 클래스에서 선언한 메소드만 호출할 수 있다.
    ```JAVA
    Object o = new Car();
    o.goFast(); // 이렇게 사용할 수 없다. goFast는 Car 클래스의 메소드인데 o는 Object
    ```

* 실제 클래스 유형에 상관없이 모든 객체 Object 클래스의 인스턴스이다.

* '다형성'은 '여러 형태'를 의미

* 자바에서 **레퍼런스** 변수의 클래스에 들어있는 메소드를 사용한다.
* 컴파일러에서는 레퍼런스가 참조하는 실제 객체의 클래스가 아닌 레퍼런스 변수를 선언할 때 지정한 유형의 클래스를 확인한다.

* 규약(protocol) : 모든 하위클래스에 있어야만 하는 정확한 메소드

* 자바에서는 다중 상속을 쓸 수 없다.

* 자바 인터페이스
  * 모든 메소드가 추상 메소드로 구성
  * 자바 인터페이스는 100% 순수한 추상 클래스와 비슷하다.
  ```JAVA
  public interface Pet {...}
  public class Dogs implements Pet {...}
  // implements를 이용하여 인터페이스를 사용
  ```

  * 어떤 클래스를 다형적인 유형으로 사용하면(상속) **같은** 상속 트리에 속한 유형만 집어넣을 수 있다. 하지만 인터페이스를 다형적인 유형으로 사용하면 어떤 상속 트리에 있는 객체도 집어넣을 수 있다. 서로 다른 상속 트리에 들어있는 클래스에서 공통적인 인터페이스를 구현할 수 있게 하는 것은 자바 API에서 중요한 부분이다. 이걸 인터페이스가 가능하게 해준다!
  * 한 클래스에서 인터페이스 여러 개를 구현할 수 있다.
  ```JAVA
  public class Dog implments Pet, Paintable {...}
  ```

  * 객체에서 그 상태를 파일에 저장하고 싶은 경우에는 Serializable 인터페이스를 구현하면 된다. 객체에서 메소드들은 서로 다른 실행 스레드로 실행시키고 싶다면 Runnable 인터페이스를 구현하면 된다.

* 확장(상속)은 한개밖에 할 수 없지만 구현(interface)는 여러 개를 할 수 있다.

* 어떤 클래스를 하위 클래스로 할지,추상 클래스로 할지, 인터페이스로 할지 결정하는 방법
  * 클래스를 새로 만들려고 할 때, 그 클래스가(Object를 제외한) 다른 어떤 유형에 대해서도 'A는 B다' 테스트를 통과할 수 없다면 그냥 클래스로 만든다.
  * 어떤 클래스의 더 구체적인 버전을 만들고 어떤 메소드를 오버라이드하거나 새로운 행동을 추가해야 한다면 하위클래스로 만든다.
  * 일련의 하위클래스에서 사용한 틀(template)을 정의하고 싶다면, 그리고 모든 하위 클래스에서 사용할 구현 코드가 조금이라도 있다면 추상 클래스로 만든다. 그리고 그 유형의 객체를 절대 만들 수 없게 만들고 싶다면 그 클래스를 추상 클래스로 만든다.
  * 상속 트리에서의 위치에 상관없이 어떤 클래스의 역할을 정의하고 싶다면 인터페이스를 사용

```JAVA
abstract class Report{
  void runReport(){  
  }

  void printReport(){
  }
}

class BuzzwordsReport extends Report{

  void runReport(){

    super.runReport();
    // super를 사용해서 상위클래스 버전을 호출
    printReport();
  }
}
```

* 추상 클래스에서는 추상 메소드와 추상 메소드가 아닌 메소드를 모두 집어넣을 수 있다.
