## Chapter 15. 네트워크와 스레드
#### 2. Thread
* 메인 스레드 : main() 메소드가 들어있는 스레드
* java.lang.Thread 클래스
  * void join() : 한 thread를 다른 thread와 결합
  * void start() : thread 시작
  * static void sleep() : thread를 대기 상태로 돌리기

* 호출 스택이 두 개 이상 있다는 것 : 여러 스택이 아주 빠르게 번갈아 실행되기 때문에 여러 스택이 동시에 실행되는 것처럼 보인다.
* 프로세서가 하나뿐인 시스템에서는 현재 실행중인 스레드는 하나일 수밖에 없다.

* thread에서 해야 하는 일 중에는 thread의 스택에서 현재(어떤 메소드에 들어있는) 어떤 선언문이 실행되고 있는지를 추적하는 작업도 포함되어 있다.

* main() 메소드에서 새로운 thread가 시작되면 메인 thread는 일시적으로 멈춘다.
* JVM에서는 여러 thread가 종료될 때까지 각 thread 사이를 왔다갔다 한다.


##### 새로운 thread 시작하는 법
1. Runnable 객체 만들기
```java
Runnable threadJob = new MyRunnable();
```
* Runnable : 인터페이스
* Runnable에는 run() 메소드만 구현해도 된다.
* Thread에서 처리할 작업을 이 클래스에서 정의
2. Thread 객체를 만들고 그 객체에 Runnable 객체 전달
```java
Thread myThread = new Thread(threadJob);
```
3. Thread 객체 시작
```java
myThread.start();
```
* 새로운 thread에서 run() 메소드가 가장 먼저 실행된다.
* Thread 객체는 run() 메소드가 종료되고 나면 절대 그 thread를 다시 시작시킬 수 없다.


##### 스레드 스케줄러
* 어떤 것이 실행되고, 어떤 것이 실행되지 않는지에 대한 결정을 내린다.
* 스케줄러는 JVM에 따라 다르게 구현
* 프로그래머가 저지르기 쉬운 실수
  → 멀티스레드 자바 프로그램을 시스템 한 대에서만 테스트 해보고 그 프로그램을 어디에서 실행하든지 스레드 스케줄러가 항상 같은 방식으로 작동할 것이라고 생각하는 것
  → 스레드 스케줄링은 어떤 특정한 방식으로 작동한다는 보장이 없기 때문에 모든 스레드가 공평하게 기호를 부여받을 수 있을거라고 보장하면 안된다.
* 어느 플랫폼에서나 실행할 수 있는 자바 프로그램을 만들기 위해서는?
  → 스레드 스케줄러가 어떤 식으로 돌아가든지 잘 작동하는 멀티스레드 프로그램을 만들어야 한다.

* 일반적으로 Thread는 JVM 스레드 스케줄러가 실행시킬 thread를 선택했다가 다른 thread에 기회를 주는 과정을 반복함에 따라 실행 가능한 상태와 실행 중인 상태에서 왔다 갔다 한다.

* 스레드 스케줄러에 가장 큰 영향을 미치는 것 : 대기 상태


##### Thread 대기 상태 - sleep()
* Thread들이 공평하게 순번을 할당받게 하는 가장 좋은 방법 중 하나 : 주기적으로 대기 상태에 집어넣어주는 것 = sleep()
* sleep()
  * sleep 메소드는 InterruptedException이라는 확인 예외를 던질 수 없기 때문에 sleep을 호출할 때는 try/catch 블록에서 선언하기


##### Thread 단점
 * 단점 = 병행성
  * thread 두 개 이상 하나의 객체의 데이터 하나에 동시에 접근하는 상황이 생길 수 있다.


##### Lock(락)
* synchronized
  * 어떤 메소드를 한 번에 한 스레드만 접근하게 하고 싶을 때 사용
* 메소드에 락을 걸게 되면, 한 스레드에서 메소드 중간에 대기 상태로 들어가더라도 처음부터 끝까지 완료할 수 있게 된다.

* 모든 객체에는 락이 존재한다. 대부분은 그 락이 풀려있고 바로 그 옆에 열쇠가 존재한다고 생각하면 된다.
* 객체의 락은 동기화된 메소드가 있을 때만 작동한다.
* 객체에 하나 이상의 동기화된 메소드가 있으면 그 객체의 락에 맞는 열쇠를 가지고 있는 스레드만 동기화된 메소드에 들어갈 수 있다.
* 어떤 스레드가 열쇠를 사용하고 있다면 그 열쇠를 사용할 동안엔느 다른 어떤 스레드도 그 객체의 동기화된 메소드에 들어갈 수 없다.

* 락은 객체마다 다 하나씩 존재
  -> 동기화된 메소드 하나에 스레드 두 개가 들어갈 수 X

* 객체의 인스턴스 변수를 조작할 가능성이 있는 메소드가 여러 개 있다면 그런 메소드는 모두 synchronized 메소드로 보호해야 한다.

* 자바 API에는 객체에 대한 락에 접근하는 기능이 없다.

* 동기화를 사용함으로써 생길 수 있는 문제
  * 동기화된 메소드를 쓰면 동기화로 인해 병행성이 제한되어서 프로그램 속도가 저하될 수 있다.
  (동기화딘 메소드에는 어느 정도 과부화가 존재)
  * 가장 큰 단점 : 동기화된 메소드 때문에 프로그램이 멎어버릴 수 있다.
